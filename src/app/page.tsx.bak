'use client'

import React, { useState, useCallback } from 'react'
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Loader2, AlertCircle, Copy, Info } from 'lucide-react'
import { Textarea } from '@/components/ui/textarea'

// Helper function to convert Figma color (0-1 range) to CSS rgba string
function figmaColorToCss(color?: { r: number; g: number; b: number; a: number }): string {
    if (!color) return 'transparent';
    const r = Math.round(color.r * 255);
    const g = Math.round(color.g * 255);
    const b = Math.round(color.b * 255);
    return `rgba(${r}, ${g}, ${b}, ${color.a})`;
}

// Helper function to get background color from fills
function getBackgroundColor(fills?: ReadonlyArray<any>): string {
    if (!fills || fills.length === 0) return 'transparent';
    const solidFill = fills.find((fill: any) => fill.type === 'SOLID' && fill.color);
    return figmaColorToCss(solidFill?.color);
}

// Helper function to render a node recursively
function renderNode(node: FigmaNode, scale: number = 0.2): React.ReactNode {
    if (!node) {
        console.log('Attempted to render null node');
        return null;
    }
    
    console.log('Rendering node:', { id: node.id, name: node.name, type: node.type, bbox: node.absoluteBoundingBox });
    
    // Se o nó não tiver absoluteBoundingBox, não podemos renderizá-lo corretamente
    if (!node.absoluteBoundingBox) {
        console.log('Node missing absoluteBoundingBox:', node.id, node.name);
        return null;
    }
    
    // Para nós de primeiro nível (frames), definir posição relativa ao container
    // Para nós filhos, definir posição absoluta em relação ao pai
    const isTopLevelNode = node.type === 'FRAME' || node.type === 'COMPONENT' || node.type === 'INSTANCE';
    
    const style: React.CSSProperties = {
        position: 'absolute',
        left: isTopLevelNode ? '0' : `${(node.absoluteBoundingBox.x - (node.parent?.absoluteBoundingBox?.x || 0)) * scale}px`,
        top: isTopLevelNode ? '0' : `${(node.absoluteBoundingBox.y - (node.parent?.absoluteBoundingBox?.y || 0)) * scale}px`,
        width: `${node.absoluteBoundingBox.width * scale}px`,
        height: `${node.absoluteBoundingBox.height * scale}px`,
        backgroundColor: getBackgroundColor(node.fills),
        borderRadius: typeof node.cornerRadius === 'number' ? `${node.cornerRadius * scale}px` : undefined,
        overflow: 'hidden',
    };
    
    // Add border if there are strokes
    if (node.strokes && node.strokes.length > 0 && node.strokeWeight) {
        const strokeFill = node.strokes.find((stroke: any) => stroke.type === 'SOLID');
        if (strokeFill) {
            style.border = `${node.strokeWeight * scale}px solid ${figmaColorToCss(strokeFill.color)}`;
        }
    }
    
    // Special handling for TEXT nodes
    if (node.type === 'TEXT' && node.characters) {
        return (
            <div style={style}>
                <p style={{
                    fontSize: node.style?.fontSize ? `${node.style.fontSize * scale}px` : undefined,
                    fontWeight: node.style?.fontWeight,
                    textAlign: node.style?.textAlignHorizontal?.toLowerCase() as any,
                    margin: 0,
                    padding: 0,
                    color: getBackgroundColor(node.fills) !== 'transparent' ? getBackgroundColor(node.fills) : '#000',
                    overflow: 'hidden',
                    textOverflow: 'ellipsis',
                }}>
                    {node.characters}
                </p>
            </div>
        );
    }
    
    // Render children recursively for container nodes
    return (
        <div style={style}>
            {node.children?.map((child: FigmaNode) => (
                <React.Fragment key={child.id}>
                    {renderNode(child, scale)}
                </React.Fragment>
            ))}
        </div>
    );
}

// Interface for Figma nodes (expanded to support more node types)
interface FigmaNode {
    id: string;
    name: string;
    type: string; // 'FRAME', 'RECTANGLE', 'TEXT', 'GROUP', 'COMPONENT', etc.
    absoluteBoundingBox?: { x: number; y: number; width: number; height: number };
    fills?: ReadonlyArray<any>;
    strokes?: ReadonlyArray<any>;
    strokeWeight?: number;
    cornerRadius?: number | { topLeft?: number; topRight?: number; bottomRight?: number; bottomLeft?: number };
    characters?: string; // For TEXT nodes
    style?: { // For TEXT nodes
        fontFamily?: string;
        fontWeight?: number;
        fontSize?: number;
        textAlignHorizontal?: string;
        textAlignVertical?: string;
        letterSpacing?: number;
        lineHeightPx?: number;
        lineHeightPercent?: number;
    };
    layoutMode?: string; // For AUTO_LAYOUT
    primaryAxisSizingMode?: string;
    counterAxisSizingMode?: string;
    paddingLeft?: number;
    paddingRight?: number;
    paddingTop?: number;
    paddingBottom?: number;
    itemSpacing?: number; // For AUTO_LAYOUT
    children?: FigmaNode[];
    parent?: FigmaNode; // Referência ao nó pai para cálculo de posição relativa
}

type FetchStatus = 'idle' | 'loading' | 'success' | 'error'

export default function FigmaExtractorPage() {
  const [figmaUrl, setFigmaUrl] = useState<string>('')
  const [status, setStatus] = useState<FetchStatus>('idle')
  const [nodes, setNodes] = useState<FigmaNode[]>([])
  const [error, setError] = useState<string | null>(null)

  const handleFetchData = async () => {
    if (!figmaUrl) {
      setError('Please enter a valid Figma File URL.');
      setStatus('error');
      return;
    }
    setStatus('loading');
    setError(null);
    setNodes([]);

    try {
      console.log('Fetching data from Figma URL:', figmaUrl);
      const response = await fetch(`/api/figma?figmaUrl=${encodeURIComponent(figmaUrl)}`)
      if (!response.ok) {
        let errorMsg = `Request failed: ${response.status}`;
        try { const data = await response.json(); errorMsg = data.details || data.error || errorMsg; } catch {} 
        throw new Error(errorMsg);
      }
      
      const data = await response.json();
      console.log('Received data from API:', data);
      
      // Verificar se recebemos um único nó (caso de nodeId específico) ou um array de nós
      if (Array.isArray(data)) {
        // Caso 1: Recebemos um array de frames/nós
        console.log(`Processando ${data.length} nós recebidos da API`);
        
        // Verificar se os nós têm as propriedades necessárias para renderização
        const validNodes = data.filter(node => {
          const hasRequiredProps = node && node.id && node.absoluteBoundingBox;
          if (!hasRequiredProps) {
            console.warn('Nó inválido encontrado:', node);
          }
          return hasRequiredProps;
        });
        
        // Processar nós para adicionar referências aos pais
        const processedNodes = processNodesWithParentReferences(validNodes);
        
        console.log(`${processedNodes.length} nós válidos para renderização`);
        setNodes(processedNodes as FigmaNode[]);
        
      } else if (data && typeof data === 'object') {
        // Caso 2: Recebemos um único nó (provavelmente de uma URL com nodeId específico)
        console.log('Processando nó único recebido da API:', data);
        
        // Verificar se o nó tem as propriedades necessárias para renderização
        if (data.id && data.absoluteBoundingBox) {
          // Processar o nó para adicionar referências aos pais
          const extractedNodes = await response.json();
      console.log('Extracted nodes:', extractedNodes);
      
      if (extractedNodes && Array.isArray(extractedNodes) && extractedNodes.length > 0) {
        setNodes(extractedNodes);
        setStatus('success');
      } else {
        setStatus('success'); // Ainda é sucesso, mas sem nós para mostrar
        setError('No frames or components found in this Figma file.');
      }    throw new Error('Node is missing required properties for rendering');
        }
      } else {
        throw new Error('API returned invalid data format.');
      }
      
      setStatus('success');
    } catch (err: any) {
      console.error("Fetch error:", err);
      setError(err.message || 'An unexpected error occurred.');
      setStatus('error');
    }
  }
  
  // Função para processar nós e adicionar referências aos pais
  const processNodesWithParentReferences = (nodes: any[]): any[] => {
    // Primeiro, criar uma cópia profunda dos nós para não modificar os originais
    const nodesCopy = JSON.parse(JSON.stringify(nodes));
    
    // Função recursiva para processar nós
    const processNode = (node: any, parent: any = null) => {
      // Adicionar referência ao pai
      if (parent) {
        node.parent = { 
          id: parent.id,
          absoluteBoundingBox: parent.absoluteBoundingBox
        };
      }
      
      // Processar filhos recursivamente
      if (node.children && Array.isArray(node.children)) {
        node.children.forEach((child: any) => {
          processNode(child, node);
        });
      }
      
      return node;
    };
    
    // Processar cada nó de primeiro nível
    return nodesCopy.map((node: any) => processNode(node));
  };
  
  // Função para processar um único nó e adicionar referências aos pais
  const processNodeWithParentReferences = (node: any): any => {
    return processNodesWithParentReferences([node])[0];
  };

  const handleCopyJson = useCallback(() => {
      if (nodes.length > 0 && nodes[0]) {
          const jsonStr = JSON.stringify(nodes[0], null, 2);
          navigator.clipboard.writeText(jsonStr);
      }
  }, [nodes]);

  // State 1 & 2: Idle and Loading
  if (status === 'idle' || status === 'loading' ) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-gray-100">
        <Card className="w-full max-w-md shadow-md">
          <CardHeader>
            <CardTitle>Extract data from Figma</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-4">
              <div className="relative">
                 <label className="text-sm font-medium text-gray-700 absolute -top-2 left-2 bg-white px-1">Figma URL</label>
                 <span className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400 cursor-pointer" title="Paste the full URL of your Figma file.">
                   <Info className="h-4 w-4" />
                 </span>
                 <Input
                    type="url"
                    placeholder="Enter Figma URL here"
                    className="border-gray-300 pt-3"
                    value={figmaUrl}
                    onChange={(e) => setFigmaUrl(e.target.value)}
                    disabled={status === 'loading'}
                  />
              </div>
              
              <Button onClick={handleFetchData} disabled={status === 'loading'} className="w-full bg-gray-800 hover:bg-gray-700 text-white">
                {status === 'loading' ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    <span>Extracting...</span> 
                  </>
                ) : (
                  <span>Extract data</span> 
                )}
              </Button>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  // State 3: Error occurred during fetch
  if (status === 'error') {
    return (
       <div className="flex items-center justify-center min-h-screen bg-gray-100">
        <Card className="w-full max-w-md shadow-md">
          <CardHeader>
            <CardTitle>Extract data from Figma</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-4">
              <div className="relative">
                 <label className="text-sm font-medium text-gray-700 absolute -top-2 left-2 bg-white px-1">Figma URL</label>
                 <span className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400 cursor-pointer" title="Paste the full URL of your Figma file.">
                   <Info className="h-4 w-4" />
                 </span>
                 <Input
                    type="url"
                    placeholder="Enter Figma URL here"
                    className="border-gray-300 pt-3" 
                    value={figmaUrl}
                    onChange={(e) => setFigmaUrl(e.target.value)}
                  />
              </div>
              <Alert variant="destructive">
                <AlertCircle className="h-4 w-4" />
                <AlertTitle>Error</AlertTitle>
                <AlertDescription>{error || 'Could not fetch data.'}</AlertDescription>
              </Alert>
              <Button onClick={() => setStatus('idle')} variant="outline" className="w-full">
                Try Again
              </Button>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  // State 4: Success (Data Extracted Layout)
  return (
    <div className="flex h-screen w-screen bg-white overflow-hidden">
      <aside className="w-72 bg-white border-r border-gray-200 p-4 flex flex-col space-y-4 overflow-y-auto">
          <div>
              <label htmlFor="figmaUrlDisplay" className="text-xs font-medium text-gray-500 flex items-center justify-between mb-1">
                  <span>Figma URL</span>
                  <span className="cursor-pointer" title="The URL of the Figma file being displayed.">
                    <Info className="h-3 w-3 text-gray-400" />
                  </span>
              </label>
              <Input 
                  id="figmaUrlDisplay"
                  type="text" 
                  value={figmaUrl} 
                  readOnly 
                  className="w-full border-gray-300 bg-gray-50 text-xs h-8 focus-visible:ring-offset-0 focus-visible:ring-0"
              />
          </div>

          {nodes.length > 0 && nodes[0] && (
            <div className="flex-grow overflow-y-auto border rounded-md p-3 bg-white space-y-3">
              <div className="flex justify-between items-center border-b pb-2 mb-2">
                  <h3 className="text-sm font-semibold truncate" title={nodes[0].name}>{nodes[0].name}</h3>
                  <Button variant="ghost" size="icon" onClick={handleCopyJson} title="Copy JSON" className="h-6 w-6">
                      <Copy className="h-4 w-4 text-gray-500" />
                  </Button>
              </div>
              <div className="space-y-3">
                  <div className="space-y-1">
                      <p className="text-xs font-medium text-gray-500">Properties</p>
                      <div className="bg-gray-50 rounded p-2 space-y-1">
                          <p className="text-xs text-gray-600">Type: <span className="font-medium text-gray-800">{nodes[0].type}</span></p>
                          {nodes[0].absoluteBoundingBox && (
                            <p className="text-xs text-gray-600">Dimensions: <span className="font-medium text-gray-800">{nodes[0].absoluteBoundingBox.width.toFixed(0)} × {nodes[0].absoluteBoundingBox.height.toFixed(0)}</span></p>
                          )}
                          {nodes[0].characters && (
                            <p className="text-xs text-gray-600">Text: <span className="font-medium text-gray-800">{nodes[0].characters.substring(0, 50)}{nodes[0].characters.length > 50 ? '...' : ''}</span></p>
                          )}
                          {nodes[0].layoutMode && (
                            <p className="text-xs text-gray-600">Layout: <span className="font-medium text-gray-800">{nodes[0].layoutMode}</span></p>
                          )}
                          {nodes[0].children && (
                            <p className="text-xs text-gray-600">Children: <span className="font-medium text-gray-800">{nodes[0].children.length}</span></p>
                          )}
                      </div>
                  </div>
                  
                  {nodes[0].fills && nodes[0].fills.length > 0 && (
                    <div className="space-y-1">
                        <p className="text-xs font-medium text-gray-500">Fill</p>
                        <div className="flex items-center gap-1">
                            {nodes[0].fills.map((fill: any, index: number) => {
                                if (fill.type === 'SOLID') {
                                    return (
                                        <div key={index} className="w-5 h-5 rounded-full border border-gray-300" 
                                             style={{ backgroundColor: figmaColorToCss(fill.color) }} />
                                    );
                                }
                                return null;
                            })}
                        </div>
                    </div>
                  )}
                  
                  {nodes[0].strokes && nodes[0].strokes.length > 0 && (
                    <div className="space-y-1">
                        <p className="text-xs font-medium text-gray-500">Stroke</p>
                        <div className="flex items-center gap-1">
                            {nodes[0].strokes.map((stroke: any, index: number) => {
                                if (stroke.type === 'SOLID') {
                                    return (
                                        <div key={index} className="w-5 h-5 rounded-full border border-gray-300" 
                                             style={{ backgroundColor: figmaColorToCss(stroke.color) }} />
                                    );
                                }
                                return null;
                            })}
                        </div>
                    </div>
                  )}
              </div>
              
              <div className="pt-2">
                  <p className="text-xs font-medium text-gray-500 mb-1">JSON Data</p>
                  <Textarea
                      readOnly
                      value={JSON.stringify(nodes[0], null, 2)}
                      className="w-full h-56 font-mono text-xs resize-none bg-gray-50 border-gray-300 focus-visible:ring-offset-0 focus-visible:ring-0"
                  />
              </div>
            </div>
          )}
      </aside>

      <main className="flex-1 flex flex-col bg-gray-50 h-full">
          <header className="bg-white border-b border-gray-200 p-3 flex justify-between items-center">
              <h1 className="text-base font-semibold">Preview</h1>
              <Button 
                  onClick={() => { setStatus('idle'); setNodes([]); setFigmaUrl(''); }} 
                  className="bg-gray-800 hover:bg-gray-700 text-white h-8 px-3 text-sm"
              >
                 + New extraction
              </Button>
          </header>

          <div className="flex-grow p-6 overflow-auto h-full w-full flex items-center justify-center">
              {nodes.length === 0 && status === 'success' && (
                  <div className="flex items-center justify-center h-full">
                      <div className="text-center p-8 bg-gray-50 rounded-lg border border-gray-200">
                          <p className="text-gray-500 mb-2">Nenhum frame ou componente encontrado para renderizar.</p>
                          <p className="text-sm text-gray-400">Tente outra URL do Figma ou verifique se a URL contém frames visíveis.</p>
                      </div>
                  </div>
              )}
              
              <div className="flex flex-col w-full h-full">
                  {nodes.map((node) => {
                      // Verificar se o nó tem todas as propriedades necessárias
                      if (!node || !node.id || !node.absoluteBoundingBox) {
                          console.log('Skipping invalid node:', node);
                          return null;
                      }
                      
                      // Exibir apenas frames e elementos de nível superior
                      if (node.type !== 'FRAME' && node.type !== 'COMPONENT' && node.type !== 'INSTANCE') {
                          return null;
                      }
                      
                      // Não precisamos mais verificar se o nó está selecionado
                      const width = node.absoluteBoundingBox?.width || 0;
                      const height = node.absoluteBoundingBox?.height || 0;
                      
                      // Pular elementos sem dimensões
                      if (width <= 0 || height <= 0) {
                          console.log('Skipping node with invalid dimensions:', node.id, node.name);
                          return null;
                      }
                      
                      // Calculate scale to fit the node in the preview container
                      // Usar a altura disponível do container para maximizar o tamanho do preview
                      const containerHeight = window.innerHeight - 150; // Altura aproximada descontando header e margens
                      const containerWidth = window.innerWidth - 300; // Largura aproximada descontando a sidebar e margens
                      
                      // Calcular a escala mantendo a proporção original
                      const scaleByHeight = containerHeight / height;
                      const scaleByWidth = containerWidth / width;
                      const scale = Math.min(scaleByHeight, scaleByWidth, 1); // Limitar a escala a no máximo 1 (tamanho real)
                      
                      const previewHeight = height * scale;
                      const previewWidth = width * scale;
                      
                      console.log('Rendering preview for node:', {
                          id: node.id,
                          name: node.name,
                          type: node.type,
                          dimensions: `${width}x${height}`,
                          scale,
                          hasChildren: (node.children && node.children.length > 0) || false
                      });
                      
                      return (
                          <div 
                              key={node.id} 
                              className="bg-white rounded-lg overflow-hidden shadow border w-full h-full flex flex-col"
                          >
                              <div className="px-3 py-2 border-b border-gray-200 flex justify-between items-center">
                                  <div className="flex items-center gap-1">
                                      <span className="text-xs font-medium truncate" title={node.name}>{node.name}</span>
                                      <span className="text-xs text-gray-500 bg-gray-100 px-1 rounded">{node.type}</span>
                                  </div>
                                  <div className="flex items-center gap-2">
                                      <span className="text-xs text-gray-500">{Math.round(width)} × {Math.round(height)}</span>
                                  </div>
                              </div>
                              <div className="relative bg-gray-100 overflow-hidden flex-1 flex items-center justify-center" style={{ height: 'calc(100vh - 200px)' }}>
                                  <div className="absolute top-0 left-0 w-full h-full flex items-center justify-center">
                                      <div className="relative" style={{ 
                                          width: '100%', 
                                          height: '100%',
                                          display: 'flex',
                                          alignItems: 'center',
                                          justifyContent: 'center',
                                          border: '1px dashed #ccc'
                                      }}>
                                          {/* Render the node with all its children */}
                                          <div style={{ 
                                              position: 'relative', 
                                              width: '100%', 
                                              height: '100%',
                                              transform: `scale(${scale})`,
                                              transformOrigin: 'center center'
                                          }}>
                                              {renderNode(node, scale)}
                                          </div>
                                      </div>
                                  </div>
                              </div>
                          </div>
                      );
                  })}
                  {nodes.filter(node => node.type === 'FRAME').length === 0 && (
                      <p className="text-gray-500 col-span-full text-center mt-10">No frames found on the first page of the Figma file.</p>
                  )}
              </div>
          </div>
      </main>
    </div>
  );
}
